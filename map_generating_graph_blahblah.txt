115개 노드
노드의 25%씩 간선 연결 개수가 다름
1개 간선 : 29 노드
2개 간선 : 22 노드 (+7)
3개 간선 : 29 노드
4개 간선 : 28 노드

286개 	노드로 계산한 간선
143개 	실제 간선 (1개 간선이 2개 노드에서 셈됨)
114개 	연결에 필수적인 간선 (노드 개수 -1)
29개 	추가 간선
※1개 간선을 가진 노드를 S라 한다. S는 막다른 길이며 더이상 다른 노드로 이어지지 않는다. 
※connected graph를 만들 때 S가 있다면 연결이 더이상 이뤄지지 않으므로 S에 연결되기 이전에 갈림길이 생겨야 한다.
※세 갈래 갈림길 1개는 S 3개를, 갈림길 2개는 S 4개를, 갈림길 3개는 S 5개를, 갈림길 n개는 S (n+2)개를 만든다.
★종합하면 3개 간선을 가진 노드 28개 분량, 다시말해 84개의 간선이 갈림길을 만든다. 나머지 연결 필수 간선 30개는 갈림길에 달라붙은 S를 연장시키는 다리와도 같다.

특정 노드와 그 노드에서 간선을 타고 2n번 이동한 노드는 서로 인접할 수 없다.

-준비 단계
	1.11*11 행렬 U1 생성, 이 행렬은 맵에 들어가지 않은 노드를 표시
	2.11*11 행렬 U2 생성, 이 행렬은 맵에 들어간 노드를 표시
	3.U1에 Node 121개 생성
	4.외곽의 시작 노드에 2개씩 간선 연결
	5.정가운데 9개 노드에 null 저장, 이후 정가운데 무작위 3개 노드에 노드 재생성
	6.내부의 정예 노드 3개, 나머지 중앙 노드 1개에 2개씩 간선 연결
-골격 라인 생성 : 외곽 8개 노드와 정중앙 8개 노드를 잇는 골격 생성
	0.그래프에서 가장 왼쪽 위 노드를 (0, 0)으로 한다.
	1.외곽 8개 노드 중 1개를 선택하고 S (Sx, Sy)이라 한다.
	2.정중앙 8개 노드 중 S1과 가장 가까운 1개를 선택하고 M (Mx, My)이라 한다.
	3.S와 M을 대각선으로 하는 정사각형에서 무작위 1점을 선택하고 C (Cx ,Cy)라고 한다.
	3-1.홀수 반복일 경우 C를 임시 변수 C1에 저장해둔다.
	4.S에서 C로 가는 최단 거리 경로 위의 모든 노드를 연결한다. 
	4-1.연결한 모든 노드를 U1에서 삭제하고 U2의 동일한 위치에 저장한다.
	5.C에서 M으로 가는 최단 거리 경로 위의 모든 노드를 연결한다.
	5-1.연결한 모든 노드를 U1에서 삭제하고 U2의 동일한 위치에 저장한다.
	6.모든 외곽 8개 노드에 대해 1~5를 반복한다.
	6-1.짝수 반복일 경우 C에서 C1로 가는 최단 거리 경로 위의 모든 노드를 연결한다.
	6-1-1.연결한 모든 노드를 U1에서 삭제하고 U2의 동일한 위치에 저장한다.
-나머지 노드 연결 : 골격에 연결되지 않은 노드들로부터 경로를 뻗어 모든 노드 연결
	1.노드 배열 T를 생성하고 정수 TC=0을 생성한다.
	2.U1에 남은 노드 중 무작위 1개를 선택하고 T에 저장한다. 
	3.T[TC]과 인접한 노드 4개에 대해 다음 진행, 어느 노드부터 진행하는지는 무작위
		-T에 저장되었다면 무시
		-T에 저장되지 않았으며 visited되지 않았다면 T에 저장
		-T에 저장되지 않았으며 visited되었다면 T에 저장하고 4번 반복문 탈출
	4.3번의 반복문 반복
	5.T[i]와 T[i+1]을 연결, T[i]를 U1에서 삭제하고 U2의 동일한 위치에 저장
	6.5번의 반복문을 (T의 길이-1)만큼 반복
	7.U1에 삭제되지 않은 노드가 있는 동안 2번~6번 반복
-추가 간선 배치
	1.U2의 무작위 노드를 선택하고 A라 지칭
	2.A의 모든 link가 null이 아니라면 (동일 row, ++col) 혹은 (++row, 0)의 노드 선택 반복
	3.A의 link 중 null이 있다면 무작위 null link에 대해 해당 방향의 노드와 연결
	4.1~3번 과정을 25번 반복



!!!FAIL!!!
1.11*11 행렬 생성, 이 행렬은 맵에 들어가지 않은 노드들을 나타냄
2.11*11 행렬 생성, 이 행렬은 맵에 들어간 노드들을 나타냄
3.시작 노드 4개, 정예 노드 3개 지정
4.골격 라인 생성
	4-1.정해진 구역에 8개 갈림길 노드 설정
		4-1-1.???가장 외곽에는 설정되지 않음, 시작 노드와의 연결을 확정짓기 위함
		4-1-2???.자신과 짝 지어질 갈림길 노드 너머에 설정되지 않음
		4-1-3.시작 노드와 정예 노드를 이은 직선 주변 1칸 이내에 설정되지 않음
	4-2.갈림길 노드를 2개씩 짝 지어 최단거리 경로 설정
	4-3.정예 노드의 각 인접 노드에서 정해진 갈림길 노드로 최단거리 경로 설정
		4-3-1.경로 설정 도중 4-2번에서 설정된 경로와 연결되면 다음으로 진행
	4-4.시작 노드의 각 인접 노드에서 정해진 갈림길 노드로 최단거리 경로 설정
		4-4-1.경로 설정 도중 4-2, 4-3번에서 설정된 경로와 연결되면 다음으로 진행
	4-※.4번의 모든 과정에서 visit되지 않은 노드만 사용
	4-★.4번 과정을 거치면 4개의 순환 그래프가 생성되어 연결에 필요한 최소 간선 개수보다 4개 더 사용하게 됨, 이후 과정에 참고할 것
5.1번의 행렬에서 무작위 노드 29개를 선택해 배열에 저장, 이 노드들은 S가 되며 이 배열을 SA라 한다
6.SA의 노드 1개를 선택해 배열에 저장, 이 배열을 RA라 한다
7.RA의 마지막 노드와 인접한 노드 중 SA에 없으면서 visited되지 않은 노드를 연결하고 RA에 저장
8.7번을 반복, SA와 TA에 저장되어 있지 않으면서 visited된 노드를 만나면 TA의 마지막 노드와 연결한 후 탈출
9.6번~8번을 반복, 1번의 행렬에 더이상 노드가 남아있지 않으면 탈출
	9-1.만약 SA의 인덱스가 먼저 없어졌다면 1번의 행렬에 있는 무작위 노드를 SA에 저장한 후 반복
★9번까지 진행할 경우 연결 필수 간선 114개, 추가 간선 4개가 사용되어 추가 간선 30개 잔존
★3노드 37+@개/4노드 0개~3노드 8or9개/4노드 14+@개

????추가 간선을 배정한 노드에 이미 연결되어 있던 간선 개수에 따른 변화
a : 1/1 > 1노드 -2, 2노드 +2
b : 1/2 > 1노드 -1, 3노드 +1
c : 1/3 > 1노드 -1, 2노드 +1, 3노드 -1, 4노드 +1
d : 2/2 > 2노드 -2, 3노드 +2-----!삭제! 6차 방정식 해결 불가, 1노드와 4노드 모두에게 간섭하지 않으므로 중요도가 낮아 삭제 대상으로 선택
e : 2/3 > 2노드 -1, 4노드 +1
f : 3/3 > 3노드 -2, 4노드 +2
1노드 : initial1-2a-b-c=29
4노드 : initial4+c+e+2f=28
2노드 : initial2+a+c-e=29
3노드 : initial3+b-c-2f=29
간선 개수 : a+b+c+e+f=25

4노드+3노드=initial4+initial3+e+b=57
e=57-initial3-initial4-b
2노드'=initial2+a+c-57+initial3+initial4+b=29
1노드+2노드=initial1+initial2+initial3+initial4-a-57=58
a=initial1+initial2+initial3+initial4-115=3 (initial1~initial4의 합은 실제 간선 개수 143개에서 현재 놓이지 않은 추가 간선 25개를 제한 값)
간선개수'=3+b+83-initial2-initial3-initial4-b+57-initial3-initial4-b+f=25
b-f=initial2+2*initial3+2*initial4-118

간선 개수'=3+b+c+57-initial3-initial4-b+f=25
c+f=initial3+initial4-35
2노드''=initial2+initial3+initial4+b+c-54=29
c=83-initial2-initial3-initial4-b
e+f=initial2+initial3+initial4-61
e=initial2+initial3+initial4-61-f
4노드'=initial4+c+initial2+iitial3+initial4-61-f+2f=28

???4노드'=initial2+2*initial3+3*initial4=124